---
title: "Using scPNMF for gene selection and data projection"
author:
  - name: Dongyuan Song
    affiliation: Bioinformatics IDP, University of California, Los Angeles
  - name: Kexin Li
    affiliation: Department of Statistics, University of California, Los Angeles

date: "`r BiocStyle::doc_date()`"
output: 
  BiocStyle::html_document:
    highlight: pygments
    toc: true
    fig_width: 6
    fig_height: 3
vignette: >
  %\VignetteIndexEntry{scPNMF}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE, include=FALSE}
knitr::opts_chunk$set(tidy = FALSE, cache = TRUE, dev = "png",
                      message = FALSE, error = FALSE, warning = TRUE)
```

# Introduction 

```{r setup}
suppressPackageStartupMessages(library(scPNMF))
suppressPackageStartupMessages(library(SingleCellExperiment))
suppressPackageStartupMessages(library(umap))
suppressPackageStartupMessages(library(ggplot2))
```

*scPNMF* is an method which learn a sparse gene encoding of single cells to facilitate gene selection for targeted gene profiling. Compared with existing gene selection methods, scPNMF has two advantages. First, its selected informative genes can better distinguish cell types, with a small number, e.g., < 200 gene. Second, it enables the alignment of new targeted gene profiling data with reference data in a low-dimensional space to facilitate the prediction of cell types in the new data.

In this manual, we will demonstrate how to use `r Githubpkg("JSB-UCLA/scPNMF")` package to select informative genes, and project datasets with limited gene numbers (e.g., targeted gene profiling) into a low-dimensional space.

# Setting up the data

Here we use `zheng4` dataset as an example. The `zheng4` dataset is stored as an `SingleCellExperiment` object. Unlike other single-cell methods, *scPNMF* **DO NOT** require normalization (e.g., normalized by cell library size). The input data is simply the raw log-count matrix.
```{r load-data}
data(zheng4, package = "scPNMF")
Input_zheng4 <- logcounts(zheng4)
```

The input data contains `dim(Input_zheng4)[1]` genes and `dim(Input_zheng4)[2]` cells.


# Step I: PNMF

The first step is the Projective Nonnegative Matrix Factorization (PNMF) dimensionality reduction. Briefly, PNMF takes advantages from both PCA and NMF (as its name!). Here is a table comparing PNMF with PCA and NMF.

Method|Optimization Problem|Non-negativity|Sparsity|Mutually Exclusiveness|New Data Projection
------|--------------------|--------------|--------|----------------------|-------------------
PNMF | $\min\limits_{\mathbf{W}} \|\mathbf{X} - \mathbf{W}\mathbf{W}^T\mathbf{X}\|\ s.t.\ \mathbf{W}\geq 0$ | Yes | Very high | Very high | Yes
PCA | $\min\limits_{\mathbf{W}} \|\mathbf{X} - \mathbf{W}\mathbf{W}^T\mathbf{X}\|\ s.t.\ \mathbf{W}^T\mathbf{W} = \mathbf{I}$ | No | Low | Low | Yes
NMF | $\min\limits_{\mathbf{W}, \mathbf{H}} \|\mathbf{X} - \mathbf{W}\mathbf{H}\|\ s.t.\ \mathbf{W},\mathbf{H}\geq 0$ | Yes | High | High | No

We run the PNMF algorithm.
```{r PNMF, eval=FALSE}
res_pnmf <- scPNMF::PNMFfun(X = Input_zheng4,
                            K = 10, method="EucDist", tol=1e-4, maxIter=1000, verboseN = TRUE)
W <- res_pnmf$Weight
S <- res_pnmf$Score
```

The return two matrix are weight matrix (projection matrix) $\mathbf{W}$ and score matrix (low-dimensional space) $\mathbf{S} = \mathbf{W}^T\mathbf{X}$. These two matrix have same meanings as outputs from PCA.

# Step II: Basis selection

The second key step of scPNMF is to select informative bases among the $K$ bases found by PNMF (i.e., columns of $\mathbf{W}$ and rows of $\mathbf{S}$) to remove unwanted variations of cells (e.g., variations irrelevant to cell types).

### 1. Functional annotation

Due to the nice interpretability of PNMF, each basis briefly represents a funtional gene cluster. Users can perform Gene Ontology (GO) analysis to annoate each basis, and decide which bases they believe are useless and remove irrelevant bases. This is an **OPTIONAL** step since it requires prior knowledge from users.
```{r annotation, eval=FALSE}
res_annotation <- scPNMF::basisAnnotate(W = W, 
                                        dim_use = 1:10,
                                        id_type = "ENSEMBL",
                                        return_fig = TRUE)
plot(res_annotation$p_comp)
```




### 2. Data-driven selection (correlations with cell library sizes and multimodality tests)
The default basis selection procedure in *scPNMF* is purely data-driven. We have two basic assumptions:
  1. A basis which is highly correlated with cell library size (here, total log-counts) should be removed since people tend to treat cell library size as an unwanted variation;
  2. A basis which shows strong multi-modal pattern should be kept since it indicates cell sub-population (e.g., cell type) structure.

The following function will perform the basis check and users can inspect the checking result.

```{r tests, eval=FALSE}
res_test <- scPNMF::basisTest(S, X=Input_zheng4,
                              return_fig = TRUE,
                              mc.cores = 1)
plot(res_test$fig)
```


### Combined basis selection function

The following wrapper function will select bases automatically.
```{r basisselect, eval=FALSE}
W_select <- scPNMF::basisSelect(W, S, X=Input_zheng4, toTest = TRUE, toAnnotate = FALSE, mc.cores = 1)
colnames(W_select)
```



# Application I: Dimensionality reduction

*scPNMF* can work as a dimensionality reduction method. Empirically, the result is usually similar to PCA. Here we use UMAP to visualize the reduced dimension space.
```{r umap, eval=FALSE}
S_select <- t(Input_zheng4) %*% W_select
cell_type <- colData(zheng4)$phenoid
umap_select <- data.frame(umap(S_select)$layout, cell_type)
colnames(umap_select) <- c("UMAP1", "UMAP2", "cell_type")

ggplot(umap_select, aes(x=UMAP1, y=UMAP2)) + geom_point(size=0.1, alpha=1, aes(color=cell_type)) +
  ggtitle("UMAP Plot") + theme_bw() +
  theme(aspect.ratio=1, plot.title = element_text(face = "bold", size=12, hjust = 0.5), legend.position = "bottom") +
  guides(color = guide_legend(override.aes = list(size=5)))
```



# Application II: Informative gene selection 

The most important application of *scPNMF* is to select informative genes (often called highly-variable genes) unsupervisedly. Compared to other gene selection methods, *scPNMF* works well with a small gene number. Here we set the desired number of gene $M = 100$.
```{r infogene, eval=FALSE}
ig <- getInfoGene(W_select, M = 100, by_basis = FALSE, return_trunW = TRUE, dim_use = NULL)
print(ig$InfoGene)
```

The return object `ig` contains a informative gene vector and a new projection matrix $\mathbf{W}_{S,(M)}$ which only relies on $M$ informative genes. 



# Application III: Data projection

$\mathbf{W}_{S,(M)}$ can be used to project new data. Since it only uses $M$ genes, this projection works for new datasets with only $M$ genes (e.g., single-cell targeted gene profiling). Here use subset the `zheng4` dataset to only keep $M$ genes to mimic a new targeted gene profiling.

```{r projection, eval=FALSE}
S_new <- getProjection(Input_zheng4[ig$InfoGene, ], ig$trunW)
```

We use UMAP to visualize the low-dimensional space using 100 genes. 
```{r umap2, eval=FALSE}
cell_type <- colData(zheng4)$phenoid
umap_new <- data.frame(umap(S_select)$layout, cell_type)
colnames(umap_select) <- c("UMAP1", "UMAP2", "cell_type")

ggplot(umap_new, aes(x=UMAP1, y=UMAP2)) + geom_point(size=0.1, alpha=1, aes(color=cell_type)) +
  ggtitle("UMAP Plot") + theme_bw() +
  theme(aspect.ratio=1, plot.title = element_text(face = "bold", size=12, hjust = 0.5), legend.position = "bottom") +
  guides(color = guide_legend(override.aes = list(size=5)))
```



# Getting help
If you meet problems when using *scPNMF*, please report it on [issues](https://github.com/JSB-UCLA/scPNMF/issues). For more questions, [email us](dongyuansong@ucla.edu)!



# Session information
```{r}
sessionInfo()
```


# References




